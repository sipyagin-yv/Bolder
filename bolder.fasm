                FORMAT  PE GUI
                stack   8192
                include "win32wx.inc"
                include "sections.inc"
                ;
                include "macros.inc"
                include "errors.inc"
                include "fileio.inc"
                include "windows.inc"
                include "crc32.inc"
                include "keys.inc"
                include "bits.inc"
                include "resource.inc"
                include "ska1.inc"
                ;include "ska2.inc"

                ; Win32-version specific constants
CHAR_WIDTH      =       8               ; in pixels
CHAR_HEIGHT     =       14              ; in pixels
SCREEN_WIDTH    =       80              ; in chars
SCREEN_HEIGHT   =       28              ; in chars

                ; ЗНАЧЕНИЯ ЗАДЕРЖКИ
DELAY           =       55              ; Базовое значение цикла задержки
EDIT_CURSOR_DELAY =     2               ; Задержка курсора редактора в циклах DELAY
SLIDE_DELAY     =       1               ; Задержка прокрутки в циклах DELAY
GAME_DELAY      =       1               ; Задержка игры в циклах DELAY

                ; Program constants
MAX_LEVELS      =       50+50+50+50     ; Максимальное количество уровней
LEVEL_INDEX     =       0               ; Начальный индекс уровней
DEMO_INDEX      =       500             ; Начальный индекс демонстрации
COPYRIGHT_INDEX =       1000
                ; Структура ресурсного файла
                ; 0..499 = уровни, 
                ; 500..999 = запись прохождения уровня
                ; 1000 = авторская информация/описание
                ;
                ; *** на будущее: 1000..1499 = названия уровней        ***
                ; *** на будущее: 2000 = авторская информация/описание ***
REC_AREA_SIZE   =       8*1024          ; Область данных для записи прохождения уровня
MAZE_WIDTH      =       16              ; Ширина лабиринта
MAZE_HEIGHT     =       12              ; Высота лабиринта
DEMOFAST        =       FALSE

                ; КОДИРОВКА ЭКРАНОВ
BLACK_SCREEN    =       -1              ; Код черного экрана
MAZE_SCREEN     =       -2              ; Код экрана лабиринта

                ; НАЧИСЛЕНИЯ ОЧКОВ
SCORE_TREASURE  =       1               ; Очки за каждую драгоценность
SCORE_BONUS     =       100             ; Очки за пройденный лабиринт

                ; НАЧАЛЬНЫЕ ЗНАЧЕНИЯ СТАТИСТИКИ
INIT_LIVES      =       5               ; Начальные попытки
INIT_SCORE      =       0               ; Начальные очки

                ; ЧЕМ ЗАКОНЧИЛАСЬ ИГРА
GAME_LVL_DONE   =       0               ; Уровень пройден
GAME_PLAY_END   =       1               ; Закончили игру
GAME_LVL_RESTART=       2               ; Перезапуск уровня
GAME_HERO_DIE   =       3               ; Герой погиб

                ; РЕЖИМ РАБОТЫ
MODE_MENU       =       0               ; Режим меню
MODE_PLAY       =       1               ; Режим игры (от начала до конца)
MODE_VIEW       =       2               ; Режим просмотра лабиринтов
MODE_VIDA       =       3               ; Режим просмотра лабиринтов (есть демо)
MODE_EDIT       =       4               ; Режим редактирования лабиринта
MODE_TEST       =       5               ; Тестовая игра (только текущ.лабиринт)
MODE_DEMO       =       6               ; Демонстрационная игра

                ; СОБЫТИЯ КЛАВИАТУРЫ
KBD_NONE        =       0               ; Клавиша не нажата
KBD_MOVE_UP     =       1
KBD_MOVE_DOWN   =       2
KBD_MOVE_LEFT   =       3
KBD_MOVE_RIGHT  =       4
KBD_ESCAPE      =       5
KBD_DESTRUCT    =       6

                ; Команды для вывода текстов
_XY             =       -1              ; Перемещение курсора ( _XY, <x>|_MEM|_IGN, <y>|_MEM|_IGN )
_ATTR           =       -2              ; Установка атрибут текста ( _ATTR, <attr> )
_SUBSTR         =       -3              ; Показать подстроку ( _SUBS, <index> )
_END            =       0               ; Конец текста ( _END )
_XY_MEM         =       -4              ; Для команды _XY, извлечь координату из ячейки памяти
_XY_IGN         =       -5              ; Для команды _XY, не изменять соответствующую координату

;=== CONST ====================================================================
                .const
                ; Константы для win32 версии
ProgramName             du      'BOLDER', 0
MainWindowClassName     du      'BolderDash_wnd', 0
MainWindowTitle         du      'Bolder Dash 3.2', 0

                ; Сообщения об ошибках
ErrorReadNotEqRequested du      'Readed bytes not equal requested bytes', 0
ErrorWritedNotEqRequested du    'Write bytes not equal requested bytes', 0
ErrorResourceTooBig     du      'Size of resource is too big to load', 0
                        ;
ActionCreateFile        du      'Create file', 0
ActionOpenFile          du      'Open file', 0
ActionCloseHandle       du      'Close file', 0
ActionGetFileSize       du      'Get file size', 0
ActionCheckSize         du      'Check file size', 0
ActionReadFile          du      'Read file', 0
ActionWriteFile         du      'Write file', 0
                ;
editorsave_question:
                du      'Try to save levels file ?', 13, 10
                du      'Please, select YES to try to save levels file again, '
                du      'or select NO to continue', 0
                ;
exitsave_question:
                du      'Try to save levels file ?', 13, 10
                du      'Please, select YES to try to save levels file again, '
                du      'or select NO to exit without saving, '
                du      'or select CANCEL to continue gaming', 0
                ;
load_question:  du      'Try to load levels file ?', 13, 10
                du      'Please, select YES to try to load levels file again, '
                du      'or select NO to exit from game, '
                du      'or select CANCEL to use original levels', 0
                ;
crc_question:   du      'Levels loaded, but CRC is wrong... Use original levels ?', 13, 10
                du      'Please, select YES to use original levels, '
                du      'or select NO to exit from game', 0

ResourceFile    du      'bolder.bin', 0


                ; Original error messages
LevCRCErrMsg    du      'Resource file "bolder.bin" is corrupted', 0
LevLoadErrMsg   du      'Can''t load resource file "bolder.bin"', 0
LevSaveErrMsg   du      'Failed to save resource file "bolder.bin"', 0

                ; Оригинальные ресурсы (с которыми поставляется игра)
ResourceOriginal file   'resources\bolder.original.bin'
                ; "Партнерский" шрифт
fontdata        file    'fnt8x8.bin'

macro           GET_LEVEL_INDEX
{
                mov     edi, [Level]
                add     edi, LEVEL_INDEX
}

macro           GET_DEMO_INDEX
{
                mov     edi, [Level]
                add     edi, DEMO_INDEX
}

macro           GET_LEVEL_PTR
{
                mov     edi, [Level]
                add     edi, LEVEL_INDEX
                call    GetResourcePtr
}

macro           GET_DEMO_PTR
{
                mov     edi, [Level]
                add     edi, DEMO_INDEX
                call    GetResourcePtr
}
                
                ; DOS-цвета текстового режима
macro           RGBA    red,green,blue
{
                DD      ((red AND 0ffh) SHL 16) OR ((green AND 0ffh) SHL 8) OR (blue AND 0ffh)
}
                ; Цвет фона
defaultpalitre: RGBA    000,000,000             ; #00: black
                RGBA    000,000,128             ; #01: blue
                RGBA    000,128,000             ; #02: green
                RGBA    000,128,128             ; #03: cyan
                RGBA    128,000,000             ; #04: red
                RGBA    128,000,128             ; #05: magenta
                RGBA    128,128,000             ; #06: brown
                RGBA    192,192,192             ; #07: light gray
                RGBA    128,128,128             ; #08: dark gray
                RGBA    000,000,255             ; #09: light blue
                RGBA    000,255,000             ; #10: light green
                RGBA    000,255,255             ; #11: light cyan
                RGBA    255,000,000             ; #12: light red
                RGBA    255,000,255             ; #13: light magenta
                RGBA    255,255,000             ; #14: yellow
                RGBA    255,255,255             ; #15: white

                ; Таблица спрайтов, 94 штуки по 9 байт
                ; 1-й байт - цвет, остальные 8 - сам спрайт
SPRT:           DB      07h, 20h,20h,20h,20h,20h,20h,20h,20h;00       - пустота                      
                DB      0Fh, 16h,17h,17h,10h,02h,03h,03h,20h;01       - камень (падают, прибивают)   
                DB      0Bh, 2Fh,2Ah,5Ch,20h,5Ch,2Ah,2Fh,20h;02       - алмаз (падают, прибивают)    
                DB      07h, 3Ah,3Ah,3Ah,3Ah,3Ah,3Ah,3Ah,3Ah;03       - земля                        
                DB      0Ch, 03h,03h,01h,03h,03h,02h,03h,03h;04       - кирпич (уничтожаемый)        
                DB      0Fh, 04h,4Fh,10h,20h,14h,03h,14h,20h;05       - человечек (грызет алмазы)    
                DB      0Ah, 23h,23h,23h,20h,23h,23h,23h,20h;06       - звери (охотятся на человечка)
                DB      0Ch, 17h,17h,17h,17h,17h,17h,17h,17h;07       - бетон (неуничтожаемый)       
                ; Спрайты - движение камней и алмазов
                DB      0Bh, 2Fh,2Ah,5Ch,20h,5Ch,2Ah,2Fh,20h;08       - алмаз (где используется, неясно)
                DB      07h, 20h,20h,20h,20h,20h,20h,20h,20h;09       - пустота
                DB      0Bh, 5Ch,2Ah,2Fh,20h,20h,20h,20h,20h;10       - алмаз падает вниз (10)
                DB      0Bh, 20h,20h,20h,20h,2Fh,2Ah,5Ch,20h;11       - алмаз падает вниз (11)
                DB      07h, 20h,20h,20h,20h,20h,20h,20h,20h;12       - пустота
                DB      07h, 20h,20h,20h,20h,20h,20h,20h,20h;13       - пустота
                DB      07h, 20h,20h,20h,20h,20h,20h,20h,20h;14       - пустота
                DB      0Fh, 02h,03h,03h,20h,20h,20h,20h,20h;15       - камень падает вниз (15)
                DB      0Fh, 20h,20h,20h,20h,16h,17h,17h,10h;16       - камень падает вниз (16)
                ; Спрайты человечка
                DB      0Fh, 04h,4Fh,10h,20h,14h,03h,1Ch,20h;17
                DB      0Fh, 1Ch,03h,14h,20h,20h,20h,20h,20h;18
                DB      0Fh, 20h,20h,20h,20h,04h,4Fh,10h,20h;19
                DB      0Fh, 20h,20h,20h,20h,04h,4Fh,10h,20h;20
                DB      0Fh, 20h,20h,20h,20h,04h,4Fh,10h,20h;21
                DB      0Fh, 20h,20h,20h,4Fh,20h,20h,04h,13h;22
                DB      0Fh, 10h,20h,20h,20h,10h,20h,20h,20h;23
                DB      0Fh, 20h,4Fh,10h,20h,14h,03h,14h,20h;24
                DB      0Fh, 20h,20h,04h,4Fh,20h,20h,04h,07h;25
                DB      0Fh, 20h,20h,20h,20h,10h,20h,20h,20h;26
                DB      0Fh, 04h,4Fh,20h,20h,14h,03h,14h,20h;27
                ; Спрайты существ
                DB      0Ah, 2Bh,2Bh,2Bh,20h,2Bh,2Bh,2Bh,20h;28
                DB      0Ah, 2Bh,20h,20h,20h,2Bh,20h,20h,20h;29
                DB      0Ah, 2Bh,20h,20h,20h,2Bh,20h,20h,20h;30
                DB      0Ah, 20h,20h,2Bh,2Bh,20h,20h,2Bh,2Bh;31
                DB      0Ah, 2Bh,2Bh,2Bh,20h,20h,20h,20h,20h;32
                DB      0Ah, 20h,20h,20h,20h,2Bh,2Bh,2Bh,20h;33
                DB      0Ah, 20h,20h,20h,20h,2Bh,2Bh,2Bh,20h;34
                DB      0Ah, 2Fh,20h,2Fh,20h,20h,2Fh,20h,2Fh;35
                DB      0Ah, 2Bh,20h,20h,20h,2Bh,20h,20h,20h;36
                DB      0Ah, 2Bh,20h,20h,20h,2Bh,20h,20h,20h;37
                DB      0Ah, 20h,20h,20h,20h,2Bh,2Bh,2Bh,20h;38
                DB      0Ah, 20h,20h,20h,20h,2Bh,2Bh,2Bh,20h;39
                DB      0Ah, 20h,20h,20h,20h,2Bh,2Bh,2Bh,20h;40
                DB      0Ah, 20h,20h,20h,20h,2Bh,2Bh,2Bh,20h;41
                ; Это у нас курсор для редактирования лабиринта
                DB      0Fh, 17h,17h,17h,17h,17h,17h,17h,17h;42
                ; Заготовки для надписей LIVES, SCORE
                DB      0Eh, 20h,20h,20h,20h,17h,20h,20h,20h;43
                DB      0Eh, 17h,20h,20h,20h,17h,14h,14h,10h;44
                DB      0Eh, 20h,20h,20h,20h,20h,07h,13h,20h;45
                DB      0Eh, 20h,06h,11h,20h,20h,16h,15h,20h;46
                DB      0Eh, 20h,20h,20h,20h,17h,20h,06h,11h;47
                DB      0Eh, 07h,10h,16h,01h,02h,15h,13h,20h;48
                DB      0Eh, 20h,20h,20h,20h,17h,03h,03h,01h;49
                DB      0Eh, 17h,03h,03h,20h,17h,14h,14h,10h;50
                DB      0Eh, 20h,20h,20h,20h,16h,03h,03h,01h;51
                DB      0Eh, 02h,03h,07h,10h,14h,14h,16h,01h;52
                DB      0Eh, 17h,20h,20h,20h,07h,14h,14h,10h;53
                DB      0Eh, 20h,20h,20h,20h,16h,03h,07h,10h;54
                DB      0Eh, 17h,20h,06h,11h,07h,14h,16h,01h;55
                DB      0Eh, 20h,20h,20h,20h,17h,03h,07h,10h;56
                DB      0Eh, 17h,14h,16h,01h,17h,02h,05h,10h;57
                DB      0Eh, 20h,20h,20h,20h,20h,17h,20h,20h;58
                DB      0Eh, 20h,20h,20h,20h,20h,17h,20h,20h;59
                ; Цифры, верхние части
                DB      0Fh, 17h,06h,06h,11h,07h,15h,16h,01h;60
                DB      0Fh, 20h,06h,11h,20h,20h,16h,15h,20h;61
                DB      0Fh, 20h,14h,16h,01h,16h,15h,14h,10h;62
                DB      0Fh, 20h,02h,07h,10h,07h,14h,16h,01h;63
                DB      0Fh, 16h,14h,17h,10h,20h,20h,17h,20h;64
                DB      0Fh, 03h,03h,07h,10h,07h,14h,16h,01h;65
                DB      0Fh, 17h,03h,07h,10h,07h,14h,16h,01h;66
                DB      0Fh, 20h,04h,13h,20h,20h,06h,11h,20h;67
                DB      0Fh, 16h,03h,07h,10h,07h,14h,16h,01h;68
                DB      0Fh, 07h,14h,16h,11h,14h,14h,16h,01h;69
                ; Тоже цифры, нижние части
                DB      0Fh, 20h,20h,20h,20h,16h,03h,17h,10h;70
                DB      0Fh, 20h,20h,20h,20h,20h,16h,11h,20h;71
                DB      0Fh, 20h,20h,20h,20h,16h,03h,07h,10h;72
                DB      0Fh, 20h,20h,20h,20h,16h,03h,07h,10h;73
                DB      0Fh, 20h,20h,20h,20h,20h,12h,17h,20h;74
                DB      0Fh, 20h,20h,20h,20h,17h,03h,03h,01h;75
                DB      0Fh, 20h,20h,20h,20h,16h,03h,03h,01h;76
                DB      0Fh, 20h,20h,20h,20h,03h,03h,07h,11h;77
                DB      0Fh, 20h,20h,20h,20h,16h,03h,07h,10h;78
                DB      0Fh, 20h,20h,20h,20h,16h,03h,07h,10h;79
                ; Заготовки для заставки (надпись BOLDER)
                DB      0Fh, 20h,20h,17h,17h,20h,20h,20h,20h;80
                DB      0Fh, 20h,20h,20h,20h,20h,20h,17h,17h;81
                DB      0Fh, 20h,20h,17h,17h,20h,20h,17h,17h;82
                DB      0Fh, 20h,20h,20h,20h,17h,17h,20h,20h;83
                DB      0Fh, 20h,20h,17h,17h,17h,17h,20h,20h;84
                DB      0Fh, 20h,20h,20h,20h,17h,17h,17h,17h;85
                DB      0Fh, 20h,20h,17h,17h,17h,17h,17h,17h;86
                DB      0Fh, 17h,17h,20h,20h,20h,20h,20h,20h;87
                DB      0Fh, 17h,17h,17h,17h,20h,20h,20h,20h;88
                DB      0Fh, 17h,17h,20h,20h,20h,20h,17h,17h;89
                DB      0Fh, 17h,17h,17h,17h,20h,20h,17h,17h;90
                DB      0Fh, 17h,17h,20h,20h,17h,17h,20h,20h;91
                DB      0Fh, 17h,17h,17h,17h,17h,17h,20h,20h;92
                DB      0Fh, 17h,17h,20h,20h,17h,17h,17h,17h;93
 .size          =       $-SPRT

                ; Начальная заставка
GameTitle:      DB      00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00 ; 1
                DB      82,88,83,00,00,00,91,00,00,00,91,00,00,00,00,00 ; 2
                DB      82,85,87,81,85,00,91,00,81,85,91,81,85,00,83,83 ; 3
                DB      82,00,91,91,00,91,91,00,91,00,91,93,85,87,92,00 ; 4
                DB      82,85,87,89,85,87,89,83,89,84,91,89,85,83,91,00 ; 5
                DB      00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00 ; 6
                DB      88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88 ; 7
                DB      00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00 ; 8
                DB      00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00 ; 9
                DB      00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00 ; 10
                DB      00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00 ; 11
                DB      00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00 ; 12

                .data
                ; Экран с информацией об очках и жизнях
GameScore:      DB      04,04,04,04,04,04,04,04,04,04,04,04,04,04,04,04 ; 1
                DB      04,04,04,04,04,04,04,04,04,04,04,04,04,04,04,04 ; 2
                DB      03,03,03,03,03,03,03,03,03,03,03,03,03,03,03,03 ; 3
                DB      03,03,03,03,03,03,03,03,03,03,03,03,03,03,03,03 ; 4
                DB      03,00,43,45,47,49,51,58,00,00,00,00,00,00,00,03 ; 5
                DB      03,00,44,46,48,50,52,59,00,00,00,00,00,00,00,03 ; 6
                DB      03,00,51,51,54,56,49,58,00,00,00,00,00,00,00,03 ; 7
                DB      03,00,52,53,55,57,50,59,00,00,00,00,00,00,00,03 ; 8
                DB      03,00,00,00,00,00,00,00,00,00,00,00,00,00,00,03 ; 9
                DB      03,03,03,03,03,03,03,03,03,03,03,03,03,03,03,03 ; 10
                DB      03,03,03,03,03,03,03,03,03,03,03,03,03,03,03,03 ; 11
                DB      04,04,04,04,04,04,04,04,04,04,04,04,04,04,04,04 ; 12

                .const
                ; Начальное меню (тебю;)
TXTMainMenu:    DB      _ATTR,0Eh
                DB      _XY,35,18,'PLAY THE GAME'       ; # 0
                DB      _XY,35,20,'LEVEL DESIGN'        ; # 1
                DB      _XY,35,22,'DEMO (WHOLE GAME)'   ; # 2
                DB      _XY,35,24,'EXIT',_END           ; # 3
                ;
TXTMenuSelector:DB      _ATTR,00h
                DB      _XY,31,18,'   '                 ; # 0
                DB      _XY,31,20,'   '                 ; # 1
                DB      _XY,31,22,'   '                 ; # 2
                DB      _XY,31,24,'   '                 ; # 3
                DB      _ATTR,0Ah,_XY,31,_XY_MEM,'-->',0CH,_END
                ;
LEVTXT:         DB      _ATTR,0Eh,_XY,28,1,'LEVEL: ',_ATTR,0Fh,_SUBSTR,0,_END
SCOTXT:         DB      _ATTR,0Eh,_XY,60,1,'SCORE: ',_ATTR,0Fh,_SUBSTR,1,_END
POPTXT:         DB      _ATTR,0Eh,_XY,45,1,'LIVES: ',_ATTR,0Fh,_SUBSTR,2,_END
EDTTXT:         DB      _ATTR,0Eh,_XY,63,1,'EDIT MODE',_END
TSTTXT:         DB      _ATTR,0Eh,_XY,63,1,'TEST MODE',_END
DMOTXT:         DB      _ATTR,0Eh,_XY,63,1,'DEMO MODE',_END
SELTXT:         DB      _ATTR,0Eh,_XY,61,1,'SELECT MODE',_END
DEMOAVAILTXT:   DB      _ATTR,0Eh,_XY,42,1,'DEMO AVAILABLE',_END
TXTVR:          DB      _ATTR,0Fh,_XY,7,1,' VERSION 3.2 PC',_END
COPYR_TXT:      DB      _ATTR,0Bh,_XY,53,1,'BY YSOFT LAB., 1991',_END
SubStringAddr:  DD      _levno, _scores, _lives

                ; НЕИНИЦИАЛИЗИРОВАННЫЕ ДАННЫЕ
                .udata
_levno:         rb      3+1             ; 3 символа
_scores:        rb      5+1             ; 5 символов
_lives:         rb      2+1             ; 2 символов
MenuMemX        RB      1
MenuMemY        RB      1

HeroCoord       RD      1               ; Координаты человечка
AlmazesCount    RD      1               ; Кол-во драгоценностей
GameMode        RD      1               ; Код режима игры
MenuNo          RD      1               ; Текущий пункт меню
Level           RD      1               ; Номер текущего лабиринта
Lives           RD      1
SoundsCount     RD      1
Score           RD      1               ; Очки

KOD             RD      1               ; Код нажатой клавиши
PRT             RB      1
PSK             RB      1
ScrollArea      RB      16*12*2
HeroDie         RB      1               ; Флаг дохлого человечка
Maze            RB      16*12           ; Тут наш лабиринт
                RB      16              ; Кирпичи, чтобы камни не проваливались
;;;MazeWork        RB      (16+2)*(12+2)
                ;
struct          Record
ptr             rd      1
ptr_begin       rd      1
ends
record          Record

; Данные воспроизведения закодированы так (после двоеточия - количество бит)
; count:5, key:3
; count - сколько циклов игры нажата клавиша key
; key - код нажатой клавиши:
;   0 - ничего не нажимали
;   1 - KBD_MOVE_UP 
;   2 - KBD_MOVE_DOWN 
;   3 - KBD_MOVE_LEFT
;   4 - KBD_MOVE_RIGHT
;   5 - KBD_ESCAPE (покинуть уровень)
;   6 - KBD_DESTRUCT (самоуничтожение)
;   7 - код не используется
RecPtr          RD      1               ; Текущий адрес записи/воспроизведения
RecSize         RD      1               ; Длина записи
RecCode         RD      1               ; Текущие данные для записи/воспроизведения
RecArray        RB      REC_AREA_SIZE   ; Массив записи
                ;
tmp_level_data  RB      256

                .code
proc            UpdateScreen
                local   client:RECT
                local   ps:PAINTSTRUCT
                local   paintdc:DWORD
                ;
                cmp     [scr.enable], 0                 ; Есть что рисовать?
                jz      .Done
                pushad
                ;
                ; Сначала нужно подготовить экран, для этого:
                ; сравнивам символы из scr.screen с символами scr.cachescreen
                ; и если символ неравен, то рисуем его в картинке scr.vmem
                ;
                push    ebp
                xor     edx, edx
 .L1:           mov     ax, [scr.screen+edx*2]
                cmp     ax, [scr.cachescreen+edx*2]
                je      .L2
                mov     [scr.cachescreen+edx*2], ax
                ; РИСУЕМ символ AL
                ; с атрибутами AH
                movzx   esi, al
                mov     esi, [scr.translCH+esi*4]       ; esi=адрес битовой карты символа
                mov     edi, [scr.translADDR+edx*4]     ; edi=адрес символа в scr.vmem
                ;
                movzx   ebx, ah
                shr     bl, 4
                mov     ebx, [scr.palitre + ebx*4]      ; ebx=цвет фона
                movzx   ecx, ah
                and     cl, 0fh
                mov     ecx, [scr.palitre + ecx*4]      ; ecx=цвет символа
                ;
                mov     ah, CHAR_HEIGHT
 .L3:           mov     al, [esi]                       ; Загрузка битовой маски
                ;
            repeat 8
                test    al, 1 SHL (8-%)
                cmovz   ebp, ebx
                cmovnz  ebp, ecx
                mov     [edi + (%-1) * 4], ebp
            end repeat
                ;
                add     edi, [scr.pitch]
                inc     esi
                dec     ah
                jnz     .L3
 .L2:           loopb   edx, SCREEN_WIDTH*SCREEN_HEIGHT, .L1
                pop     ebp
                ;
                ; А теперь выводим картинку, нарисованную в scr.vmem, в клиентскую часть окна 
                ;
                invoke  GetClientRect, [MainWindow], addr client
                invoke  BeginPaint, [MainWindow], addr ps
                mov     [paintdc], eax
                ;
;                invoke  SelectObject, [scr.dc], [scr.dib]
;                push    eax
                ;
;                invoke  StretchBlt, \
;                        [paintdc], 0, 0, [client.right], [client.bottom], \
;                        [scr.dc], 0, 0, [scr.w], [scr.h], \
;                        SRCCOPY
                invoke  StretchDIBits, \
                        [paintdc], \
                        0, 0, [client.right], [client.bottom], \
                        0, 0, [scr.pixels.x], [scr.pixels.y], \
                        [scr.vmem], scr.bih, DIB_RGB_COLORS, SRCCOPY
                ;
;                pop     eax
;                invoke  SelectObject, [scr.dc], eax
                ;
                invoke  EndPaint, [MainWindow], addr ps
                ;
                popad
.Done:          ret
endp

proc            MainWindowProc  hwnd, uMsg, wParam, lParam
                mov     eax, [uMsg]
                be      eax, WM_PAINT, .paint
                be      eax, WM_DESTROY, .destroy
                be      eax, WM_SIZE, .resize
                be      eax, WM_KEYDOWN, .keydown
                be      eax, WM_KEYUP, .keyup
                be      eax, WM_TIMER, .timer
                be      eax, WM_CLOSE, .close
                invoke  DefWindowProc, [hwnd], [uMsg], [wParam], [lParam]       ; default window proc
                ret
                ;
 .close:        invoke  ExitProcess, 0
                ;
 .keydown:      movzx   eax, word [wParam]
                mov     [ScanKeyboardMap+eax], TRUE
                mov     [KeyCode], eax
                xor     eax, eax
                ret
                ;
 .keyup:        movzx   eax, byte [wParam]
                mov     [ScanKeyboardMap+eax], FALSE
                mov     [KeyCode], 0
                xor     eax, eax
                ret
                ;
 .destroy:      invoke  PostQuitMessage, 0
                xor     eax, eax
                ret
                ;
 .paint:        call    UpdateScreen
                xor     eax, eax
                ret
                ;
 .resize:       invoke  InvalidateRect, [MainWindow], NULL, FALSE
                xor     eax, eax
                ret
                ;
 .timer:        mov     [TimerEvent], TRUE
                xor     eax, eax
                ret
endp

                .udata
KeyCode         RD      1               ; Код последней нажатой клавиши
TimerEvent      RD      1               ; =TRUE, если сработал таймер
ScanKeyboardMap RB      256             ; Карта нажатых клавиш

                ; Коды выхода из ProcessMessages
PM_QUIT         equ     -1
PM_TIMER        equ     -2

                ; Флаги условий выхода из цикла
PM_EXIT_BY_TIMER        equ     00000001h
PM_EXIT_BY_KEY          equ     00000002h

                .code
                ;
                ; ProcessMessages - обработать входящие сообщения
                ; Основная процедура для работы с клавиатурой
                ;
                ; IN    flags - Условия выхода из цикла (PM_EXIT_BY_TIMER, PM_EXIT_BY_KEY)
                ;
                ;       delay - Задержка, в интервалах скорости игры 
                ;               (используется, если указан флаг PM_EXIT_BY_TIMER)
                ;               В процессе ожидания устанавливаем/сбрасываем флаги нажатых
                ;               клавиш в массиве ScanKeyboardMap.
                ;                               
                ; REMARK        Если delay = 0, устанавливается флаг PM_EXIT_BY_KEY
                ;
                ; OUT   eax = PM_QUIT, требуется выход из программы (нажата клавиша Alt+F4, или кнопка закрытия окна)
                ;       eax = PM_TIMER, выход по истечению таймера
                ;       eax = 0 .. 255, выход по нажатию клавиши (eax=код клавиши)
                ;
proc            ProcessMessages flags:DWORD, delay:DWORD
                local   msg:MSG
                ;
                pushad
                mov     [KeyCode], FALSE
                mov     [TimerEvent], FALSE
                invoke  InvalidateRect, [MainWindow],NULL,FALSE ; Перерисовываем экран
                ;
                fclear? [flags], PM_EXIT_BY_TIMER, .L1          ; Проверяем параметры
                bne     [delay], 0, .Loop
                mov     [delay], 1
                jmp     .Loop
                ;
 .L1:           fset?   [flags], PM_EXIT_BY_KEY, .Loop          ; Выход по таймеру не задан, 
                or      [flags], PM_EXIT_BY_KEY                 ; проверяем выход по клавише
                ;
 .Loop:         invoke  GetMessage, addr msg, 0, 0, 0           ; Читаем ЛЮБОЕ сообщение
                be      eax, 0, .PM_QUIT
                invoke  TranslateMessage, addr msg              ; Трансляция сообщения
                invoke  DispatchMessage, addr msg               ; Обработка сообщения
                ;
                be      [KeyCode], FALSE, .L2                   ; Проверка на нажатие клавиши
                fset?   [flags], PM_EXIT_BY_KEY, .PM_KEY        ; Требуется выйти по нажатию клавиши?
                ;
 .L2:           bne     [TimerEvent], TRUE, .Loop               ; Проверка на таймер
                fclear? [flags], PM_EXIT_BY_TIMER, .Loop        ; Требуется выйти по таймеру?
                dec     [delay]
                jz      .L3
                mov     [TimerEvent],FALSE                      ; Ожидаем следующего события таймера
                jmp     .Loop
 .L3:           popad
                return  PM_TIMER
                ;
 .PM_QUIT:      popad
                return  PM_QUIT
                ;
 .PM_KEY:       popad
                return  [KeyCode]
endp

;==============================================================================;
;  MAIN BOLDER                                                                 ;
;==============================================================================;
                .code
proc            start
                mov     eax, DEMO_FROM_BEGIN
                stdcall crc32InitTable
                stdcall LoadMainFiles           ; В этой процедуре можем выйти
                ;
                stdcall SetVideoModes
                call    InstallKeyboard
                call    DrawFrameBolder         ; Находится на экране постоянно
                mov     [MenuNo],0
                ;=== НАЧАЛО - Main Menu ===
MainMenu:       mov     [GameMode],MODE_MENU
                mov     esi,BLACK_SCREEN
                mov     edi,GameTitle
                call    SlideUpAndBeep          ; Чёрные экран -> заставка
                ;
MenuSelect:     mov     [GameMode],MODE_MENU
                mov     esi,TXTMainMenu         ; Рисуем меню
                call    DrawTextBolder
                ;
MenuLoop:       mov     eax,[MenuNo]
                and     eax, 11b
                mov     [MenuNo], eax
                shl     al,1
                add     al,18
                mov     [MenuMemY],al
                ;
                mov     esi,TXTMenuSelector
                call    DrawTextBolder
                ;
                stdcall ProcessMessages, PM_EXIT_BY_KEY, 0
                switch  eax, PM_QUIT,   .MenuQuit,   \
                             VK_UP,     .MenuUp,     \
                             VK_DOWN,   .MenuDown,   \
                             VK_ESCAPE, .MenuQuit,   \
                             VK_RETURN, .MenuSelect, \
                             VK_HOME,   .MenuHome,   \
                             VK_END,    .MenuEnd
                jmp     MenuLoop
                ;
 .MenuHome:     mov     [MenuNo], 0
                jmp     MenuLoop
                ;
 .MenuEnd:      mov     [MenuNo], 11b
                jmp     MenuLoop
                ;
 .MenuUp:       dec     [MenuNo]
                jmp     MenuLoop
                ;
 .MenuDown:     inc     [MenuNo]
                jmp     MenuLoop
                ;
 .MenuSelect:   mov     eax,[MenuNo]
                switch  eax,0, .MenuGame, \
                            1, .MenuEdit, \
                            2, .MenuDemo, \
                            3, .MenuQuit
                jmp     MenuLoop
                ;
 .MenuEdit:     stdcall SelectLevelForEditing
                mov     [GameMode],MODE_MENU
                mov     esi,Maze
                mov     edi,GameTitle
                call    SlideUp
                jmp     MenuSelect
                ;
 .MenuGame:     call    GAME
                jmp     MenuSelect
                ;
 .MenuDemo:     call    DEMO_FROM_BEGIN
                jmp     MainMenu
                ;
 .MenuQuit:
                ; TRY TO SAVE FILES
 .save:         call    SaveMainFiles
                or      eax, eax
                jz      .L1
                stdcall ShowError, LevSaveErrMsg, exitsave_question, MB_YESNOCANCEL
                switch  eax, IDYES, .save, \
                             IDNO, .L1, \
                             IDCANCEL, MenuSelect
                jmp     MenuSelect
                ; Выбрали Cancel - выход без записи
 .L1:           mov     esi,GameTitle
                mov     edi,BLACK_SCREEN
                call    SlideDown
                call    DoneProc
                invoke  ExitProcess, 0
endp

proc            DoneProc
                invoke  KillTimer, [MainWindow], 1
                stdcall DeleteScreen
                stdcall DeleteMainWindow
                ret
endp

                ; Процедура читает файл с уровнями
                ; IN    ---
                ; OUT   прочитанный файл уровней, в [resaddr] адрес области памяти с уровнями
                ; REMARK
                ;       в процессе чтения могут произойти ошибки, в этом случае предлагаем
                ;       очистить все уровни или же восстановить их в оригинальном виде из архива внутри exe файла
proc            LoadMainFiles
                mov     [resaddr], _Resource
                mov     [reschanged], FALSE
                ;
 .Load:         stdcall LoadFile, ResourceFile, _Resource, RESOURCE_AREA_SIZE
                jc      .ERRORLoad
                ;;;call    CalculateResourceCRC - раскомментировать, если нужно пересчитать контр.суммы
                stdcall CheckResourceCRC
                jc      .ERRORCrc
                ret

 .ExtractOriginal:
                ; Извлекаем из внутреннего архива оригинальные уровни (на момент компиляции игры)
                mov     esi, ResourceOriginal
                mov     edi, _Resource
                mov     [resaddr], edi
                mov     [reschanged], FALSE
                mov     ecx, [esi + ResourceMainHeader.size]
                rep     movsb                
                ret

 .ERRORExit:    invoke  ExitProcess, -1

 .ERRORLoad:    stdcall ShowError, LevLoadErrMsg, load_question, MB_YESNOCANCEL
                switch  eax, IDYES, .Load, \
                             IDNO, .ERRORExit, \
                             IDCANCEL, .ExtractOriginal
                jmp     .ERRORExit

 .ERRORCrc:     CLEARERROR
                stdcall ShowError, LevCRCErrMsg, crc_question, MB_YESNO
                switch  eax, IDYES, .ExtractOriginal, \
                             IDNO, .ERRORExit
                jmp     .ERRORExit
endp

                ; Процедура записывает файл уровней
                ; IN    ---
                ; OUT   eax = 0, save is OK
                ;       eax =-1, save is failed (error information in error structure)
proc            SaveMainFiles
                be      [reschanged], FALSE, .ok        ; Если ресурс не изменялся, смысл его записывать?

                mov     eax, [resaddr]
                stdcall SaveFile, ResourceFile, eax, [eax+ResourceMainHeader.size]
                jc      .fail
                mov     [reschanged], FALSE             ; Ресурс записан, и не менялся более
 .ok:           xor     eax, eax                        ; Всё в порядке
                ret

 .fail:         mov     eax, -1                         ; Сигнализируем об ошибке
                ret
endp

proc            InstallKeyboard
                mov     edi, ScanKeyboardMap
                mov     ecx, 256/4
                xor     eax, eax
                rep     stosd
                ret
endp

                .data
game_keys:      db      VK_LEFT,       VK_RIGHT,       VK_UP,       VK_DOWN,       VK_ESCAPE,  VK_DELETE,    0
                .const
game_events:    db      KBD_MOVE_LEFT, KBD_MOVE_RIGHT, KBD_MOVE_UP, KBD_MOVE_DOWN, KBD_ESCAPE, KBD_DESTRUCT, KBD_NONE
                .code
                ; Вернуть код нажатой клавиши (коды считываются в процедуре ProcessMessages)
                ; Если ScanKeyboardMap[КодКлавиши] = TRUE, то клавиша нажата
                ; Вернуть KBD_NONE, если ни одна из клавиш не нажата
                ; Иначе возвращаем код клавиши в игровой кодировке (KBD_xxxx)
                ; IN    -
                ; OUT   eax = pressed key, or KBD_NONE if no keys pressed
proc            GrabKeyCode uses esi
                xor     eax, eax
                xor     esi, esi
 .Loop:         mov     al, [esi + game_keys]                   ; Get key code
                or      eax, eax
                jz      .done
                cmp     [eax + ScanKeyboardMap], TRUE           ; Key pressed ?
                je      .done
                inc     esi
                jmp     .Loop
 .done:         mov     al, [esi + game_events]                 ; Key pressed, get game-code
                ret                
endp

proc            BeepBolder
                pushad
;;                pushad
;;                mov     al,0B6h
;;                out     043h,al
;;                mov     ax,002BCh               ; 1 193 180 (опорная частота таймера) / 02BCh = 1704 Гц
;;                out     042h,al                 ; Т.о., число для записи в порт 42h 
;;                mov     al,ah                   ; = опорная частота / нужная частота в Гц
;;                out     042h,al
;;                in      al,061h                 ; Включить динамик
;;                or      al,003h
;;                out     061h,al
;;                mov     cx,0A000h
;;                loop    $
;;                in      al,061h                 ; Выключить динамик
;;                and     al,0FCh
;;                out     061h,al
;;                mov     al,0B6h
;;                out     43h,al
;;                mov     al,0
;;                out     42h,al
;;                out     42h,al
;;                mov     cx,0A000h
;;                loop    $
                popad
                ret
endp

                ; Подготовить шрифт
proc            PrepareFont
                assert  sizeof.Scr.fontdata2 = 256*14
                mov     esi,fontdata
                mov     edi,scr.fontdata2
                mov     ecx,128
                ; Шрифт увеличивается с 8 строк до 14 строк:
                ; 01234567 -> 01122334455667
 .M1:           movsb
                mov     dl,6
 .M2:           lodsb
                stosb
                stosb
                dec     dl
                jnz     .M2
                movsb
                loop    .M1
                ; Оставшиеся 128 символов заполнить нулями
                mov     ecx, 128 * 14 / 4
                xor     eax, eax
                rep     stosd
                ret
endp

proc            SetVideoModes
                mov     [scr.enable], 0         ; disable paint
                call    CreateMainWindow
                stdcall CreateScreen, SCREEN_WIDTH, SCREEN_HEIGHT
                invoke  SetTimer, [MainWindow], 1, DELAY, NULL        ; Включаем таймер
                ret
endp

                ; Вывести символ на экран
                ; IN    dh = координата y
                ;       dl = координата x
                ;       ah = атрибуты символа
                ;       al = выводимый символ
                ;
proc            DrawCharBolder uses edx esi
                movzx   esi, dh                 ; addr = DH * 160 + DL * 2
                imul    esi, 160
                movzx   edx, dl
                lea     esi, [esi + edx*2]
                mov     [scr.screen + esi], ax
;;ДЛЯ ТЕСТОВЫХ ЦЕЛЕЙ
;;                pushad
;;                invoke  InvalidateRect, [MainWindow], NULL, FALSE
;;                call    UpdateScreen
;;                popad
                ret
endp

                ; Загрузка значения координаты в регистр AL
                ; Если координата = _XY_IGN, игнорировать координату (не загружать в AL)
                ; Если координата = _XY_MEM, загрузить значение из ячейки памяти mem
                ; Любое другое значение - это значение координаты (константа)
macro           LOAD_COORD  reg, mem
{               local   .done, .setmem
                be      al, _XY_IGN, .done
                be      al, _XY_MEM, .setmem
                mov     reg, al
                jmp     .done
 .setmem:       mov     reg, mem
 .done:
}

proc            DrawTextBolder uses   eax edx esi
                push    dword -1
 .Loop:         lodsb
                switch  al, _END, .endtxt, \
                            _XY, .xy,      \
                            _ATTR, .attr,  \
                            _SUBSTR, .subs
                call    DrawCharBolder
                inc     dl
                jmp     .Loop
                ;
 .xy:           lodsb                   ; read X
                LOAD_COORD  dl, [MenuMemX]
                lodsb                   ; read Y
                LOAD_COORD  dh, [MenuMemY]
                jmp     .Loop
                ;
 .attr:         mov     ah,[esi]
                inc     esi
                jmp     .Loop
                ;
 .subs:         inc     esi
                push    esi
                movzx   esi, byte [esi-1]
                mov     esi, [SubStringAddr + esi*4]
                jmp     .Loop
                ;
 .endtxt:       pop     esi
                bne     esi, -1, .Loop
                ret
endp

macro           COPYDG  froma, toa, number
{               local   .L1
                mov     esi, froma
                mov     edi, toa
                mov     ecx, number
 .L1:           lodsb
                add     al, '0'
                stosb
                loop    .L1
                mov     al, _END
                stosb
}

                ; show "LEVEL: xxx" information
proc            LEV_INFO
                mov     edx,[Level]
                inc     edx
                call    IntegerToString
                COPYDG  ED+ED.size-3, _levno, 3
                mov     esi,LEVTXT
                call    DrawTextBolder
                ret
endp

                ; show "SCORE: xxxxx" information
proc            SCO_INFO
                mov     edx,[Score]
                call    IntegerToString
                COPYDG  ED+ED.size-5, _scores, 5
                mov     esi,SCOTXT
                call    DrawTextBolder
                ret
endp

                ; show "LIVES: xx" information
proc            POP_INFO
                mov     edx,[Lives]
                call    IntegerToString
                COPYDG  ED+ED.size-2, _lives, 2
                mov     esi,POPTXT
                call    DrawTextBolder
                ret
endp

                ; Очки и попытки на информационную панель
proc            PrepareGameScoreScreen
                ; ПОПЫТКИ
                mov     edx,[Lives]
                call    IntegerToString
                mov     esi,ED+ED.size-2
                mov     edi,GameScore+89
                mov     ecx,2
                call    StringToGameScoreScreen
                ; ОЧКИ
                mov     edx,[Score]
                call    IntegerToString
                mov     esi,ED+ED.size-5
                mov     edi,GameScore+121
                mov     ecx,5
                call    StringToGameScoreScreen
                ret
endp

proc            StringToGameScoreScreen
 .L1:           mov     al,[esi]
                add     al,60
                mov     [edi],al
                add     al,10
                mov     [edi-16],al
                inc     esi
                inc     edi
                loop    .L1
                ret
endp

                .udata
ED              RB      12              ; Для форматирования чисел
 .size          =       $-ED            ; Размер: чтобы гарантированно вместился Int32

                .code
                ; Преобразование числа из двоичного 
                ; представления (EDX) в строковое (ED[12])
proc            IntegerToString uses eax ebx edx edi
                xor     eax, eax
                mov     edi, ED+ED.size-1
                mov     [edi-3], eax
                mov     [edi-3-4], eax
                mov     [edi-3-4*2], eax
                ;
                mov     eax, edx
                mov     ebx, 10
 .L1:           xor     edx, edx
                div     ebx
                mov     [edi], dl
                dec     edi
                or      eax, eax
                jnz     .L1
                ret
endp

proc            ClearStatusBar
                mov     [GameMode],MODE_MENU
                call    DrawStatusBar
                ret
endp

; MODE_MENU     =  "                      BY YSOFT LAB., 1991"
; MODE_PLAY     =  "LEVEL: 001     LIVES: 05     SCORE: 00000"
; MODE_VIEW     =  "LEVEL: 001                    SELECT MODE"
; MODE_VIDA     =  "LEVEL: 001   DEMO AVAILABLE   SELECT MODE"
; MODE_EDIT     =  "LEVEL: 001                      EDIT MODE"
; MODE_TEST     =  "LEVEL: 001                      TEST MODE"
; MODE_DEMO     =  "LEVEL: 001                      DEMO MODE"
proc            DrawStatusBar
                mov     eax, 0F20h              ; Очищаем строку для информации
                lea     edi, [scr.screen + 1*160 + 23*2]
                mov     ecx, 50
                rep     stosw
                ;
                mov     eax,[GameMode]          ; Показываем статусную строку 
                be      eax,MODE_MENU,.Menu     ; в зависимости от текущего режима
                be      eax,MODE_PLAY,.Play
                be      eax,MODE_VIEW,.View
                be      eax,MODE_VIDA,.ViDa
                be      eax,MODE_EDIT,.Edit
                be      eax,MODE_TEST,.Test
                be      eax,MODE_DEMO,.Demo
                ret
                ;
 .ViDa:         mov     esi,DEMOAVAILTXT        ; "demo available"
                call    DrawTextBolder
 .View:         call    LEV_INFO
                mov     esi,SELTXT              ; "select mode"
                call    DrawTextBolder
                ret
                ;
 .Edit:         call    LEV_INFO
                mov     esi,EDTTXT
                call    DrawTextBolder
                ret
                ;
 .Test:         call    LEV_INFO
                mov     esi,TSTTXT
                call    DrawTextBolder
                ret
                ;
 .Play:         call    LEV_INFO
                call    POP_INFO
                call    SCO_INFO
                ret
                ;
 .Demo:         call    LEV_INFO
                mov     esi,DMOTXT
                call    DrawTextBolder
                ret
                ;
 .Menu:         mov     esi,COPYR_TXT
                call    DrawTextBolder
                ret
endp


proc            MakeSoundEffects
                mov     ecx,[SoundsCount]
                jcxz    .LE
 .L3:           call    SOO
                loop    .L3
 .LE:           ret
endp

                ; Draw frame 66 * 26 (permanent stay on the screen)
proc            DrawFrameBolder
                mov     ax, 0917h                       ; Символ - квадрат размером в знакоместо
                lea     edi, [scr.screen + 2*160 + 7*2] ; Левый верхний угол рамки
                mov     ecx, 66
 .L1:           mov     [edi], ax
                mov     [edi + 25*160], ax
                add     edi, 2
                loop    .L1
                ;
                lea     edi, [scr.screen + 3*160 + 7*2]
                mov     ecx, 24
 .L2:           mov     [edi], ax
                mov     [edi + 65*2], ax
                add     edi, 160
                loop    .L2
                ;
                mov     esi,TXTVR
                call    DrawTextBolder
                ret
endp

                ; Компрессия уровня
proc            CompressLevel
                ; Временно сохраняем уровень
                MOVEBLK Maze, tmp_level_data, MAZE_WIDTH*MAZE_HEIGHT
                ; Извлекаем уровень из архива
                call    ExpandLevel
                ; Сравниваем два уровня на одинаковость
                CMPBLK  Maze, tmp_level_data, MAZE_WIDTH*MAZE_HEIGHT
                je      .Done
                ; Копируем уровень обратно в Maze
                MOVEBLK tmp_level_data, Maze, MAZE_WIDTH*MAZE_HEIGHT
                ; И "сжимаем" Maze -> tmp_level_data
                stdcall BitsInit, tmp_level_data
                mov     esi,Maze
                mov     ecx, MAZE_WIDTH * MAZE_HEIGHT
                xor     eax, eax
 .Loop:         lodsb
                stdcall BitsPut, eax, 3
                loop    .Loop
                stdcall BitsFlush
                ;
                mov     ecx, eax                ; Сохраняем сжатый уровень в ресурсах
                mov     esi, tmp_level_data     ; ecx = размер сжатый данных (получено от BitsFlush)
                GET_LEVEL_INDEX
                call    ReplaceResource         ; Сохранить в ресурсах новый уровень
                ;
                xor     esi, esi
                xor     ecx, ecx
                GET_DEMO_INDEX
                call    ReplaceResource         ; Удалить демо
                ;
 .save:         call    SaveMainFiles
                ; В регистре eax = 0, запись успешна; eax = -1 нет
                or      eax, eax
                jz      .Done
                ; Обрабатываем ошибку
                stdcall ShowError, LevSaveErrMsg, editorsave_question, MB_YESNO
                switch  eax, IDYES, .save
 .Done:         ret
endp

                ; Расшифровка лабиринта
                ; IN    [Level] - maze index in resource (0..MAX_RESOURCE-1)
proc            ExpandLevel
                pushad
                GET_LEVEL_PTR                           ; esi = addr of resource; eax = size of resource
                stdcall BitsInit, esi
                mov     edi, Maze
                mov     ecx, MAZE_WIDTH * MAZE_HEIGHT
 .Loop:         stdcall BitsGet, 3
                stosb
                loop    .Loop
                ;
                mov     ecx,MAZE_WIDTH
                mov     al,7                            ; Внизу - бетон - непробиваемый ничем (ранее было 4)
                rep     stosb
                popad
                ret
endp

                ;
                ; Рисуем лабиринт
                ; IN    mazeAddr=адрес лабиринта (если 0, то рисуем с адреса Maze)
                ; 
proc            DrawLevel       mazeAddr:DWORD
                pushad
                mov     esi, [mazeAddr]
                default esi, Maze
                mov     edi, scr.screen + 3*160+8*2
                mov     ch, MAZE_HEIGHT
 .LoopY:        mov     cl, MAZE_WIDTH
                push    edi
 .LoopX:        lodsb                           ; al = sprite_index
                push    esi
                movzx   esi,al
                lea     esi, [esi*8+esi+SPRT]   ; esi = sprite_index*9 + SPRT
                mov     ah, [esi]               ; Атрибуты спрайта
                inc     esi
            repeat 4
                lodsb
                stosw
            end repeat
                add     edi,160-4*2
            repeat 4
                lodsb
                stosw
            end repeat
                sub     edi,160
                pop     esi
                loopr   cl, .LoopX
                pop     edi
                add     edi,160*2
                loopr   ch, .LoopY
                ;
                call    DrawStatusBar
                popad
                ret
endp

                ; Подсчет количества драгоценностей
proc            CalculateLevel
                mov     esi,Maze
                mov     edx,0
                mov     ecx,192
 .L1:           bne     byte [esi],2,.L2
                inc     edx
 .L2:           inc     esi
                loop    .L1
                mov     [AlmazesCount],edx
                ; Найти координаты человечка и поместить их в HeroCoord
                mov     edi,Maze
                mov     ecx,16*12
                mov     al,5
                repne   scasb
                dec     edi
                mov     [HeroCoord],edi
                ret
endp

;=== GAME CYCLE ===============================================================
proc            GAME
                mov     [Level],0               ; Номер уровня
                mov     [Lives],INIT_LIVES      ; Попыток
                mov     [Score],INIT_SCORE        ; Очки
                call    PrepareGameScoreScreen
                mov     esi,GameTitle
                mov     edi,GameScore
                call    SlideUpAndBeep          ; Заставка => Очки
                mov     [GameMode],MODE_PLAY
 .PlayLevel:    stdcall ProcessMessages, PM_EXIT_BY_TIMER, 15; Пауза на экране с очками и попытками
                mov     esi,GameScore
                mov     edi,MAZE_SCREEN
                call    SlideUpAndBeep          ; Очки ==> Лабиринт
                call    PlayLoop
                switch  eax, GAME_LVL_DONE,   .L1, \
                             GAME_LVL_RESTART,.L2, \
                             GAME_HERO_DIE,   .L2, \
                             GAME_PLAY_END,   .L3
                
                ; РЕСТАРТ УРОВНЯ ИЛИ ГЕРОЙ ПОГИБ
 .L2:           call    WaitForSilent
                dec     [Lives]
                call    DrawStatusBar
                call    PrepareGameScoreScreen
                mov     esi,Maze
                mov     edi,GameScore
                call    SlideDownAndBeep
                bne     [Lives],0,.PlayLevel   ; Переход, если есть попытки
                jmp     .GameOver
                
                ; УРОВЕНЬ ПРОЙДЕН
 .L1:           call    EndLevelSignal
                inc     [Lives]
                inc     [Level]
                add     [Score],SCORE_BONUS
                call    DrawStatusBar
                call    PrepareGameScoreScreen
                mov     esi,Maze
                mov     edi,GameScore
                call    SlideDownAndBeep
                bne     [Level],MAX_LEVELS,.PlayLevel

 .GameOver:     call    BeepBolder              ; ИГРА ОКОНЧЕНА!!!
                mov     [GameMode],MODE_MENU
                jmp     .Title

                ; ВЫХОД ИЗ ИГРЫ В ГЛАВНОЕ МЕНЮ
 .L3:           mov     esi,Maze
                mov     edi,GameScore
                call    SlideDownAndBeep
                call    ClearStatusBar
 .Title:        stdcall ProcessMessages, PM_EXIT_BY_TIMER, 25; Пауза
                mov     esi,GameScore
                mov     edi,GameTitle
                call    SlideDownAndBeep
 .Done:         ret
endp
;==============================================================================

;;;=== TEST CYCLES ==============================================================
;;TEST1:          mov     [Lives],0
;;                mov     [Score],0
;;                call    PrepareGameScoreScreen                    ; Очки никогда не показываются...
;; .TestLoop:     call    ExpandLevel
;;                mov     [GameMode],MODE_TEST
;;                call    PlayLoop
;;                be      ax,GAME_PLAYER_DIE,.L2
;;                be      ax,GAME_LEVEL_BREAK,.L2
;;                be      ax,GAME_LEVEL_DONE,.L1
;;                be      ax,GAME_PLAY_BREAK,.L1
;; .L2:           call    WaitForSilent
;;                mov     si,Maze                 ; Лабиринт => Очки
;;                mov     di,GameScore
;;                call    SlideDownAndBeep
;;                mov     cx,15                   ; Пауза
;;                call    MakeDelay
;;                mov     si,GameScore
;;                mov     di,MAZE_SCREEN
;;                call    SlideUpAndBeep          ; Очки ==> Лабиринт
;;                jmp     .TestLoop
;; .L1:           ret
;;;==============================================================================
;;

;=== DEMO CYCLES ==============================================================
proc            DEMO
                push    [GameMode]
                mov     [GameMode],MODE_DEMO
 .DemoLoop:     GET_DEMO_PTR                    ; Есть данные для демо?
                or      eax, eax
                jz      .NextLevel
                ;;;call    InitRecPlay - в PlayLoop тоже вызывается
                mov     esi,BLACK_SCREEN
                mov     edi,MAZE_SCREEN
                call    SlideUpAndBeep          ; Черный экран -> Лабиринт
                call    PlayLoop                ; >ИГРОВОЙ ЦИКЛ<
                switch  eax, GAME_LVL_DONE,    .HideLevel, \
                             GAME_PLAY_END,    .DemoEnd,   \
                             GAME_HERO_DIE,    .DemoEnd,   \
                             GAME_LVL_RESTART, .DemoEnd
 .HideLevel:    mov     esi,Maze
                mov     edi,BLACK_SCREEN
                call    SlideUp                 ; Лабиринт -> черный экран
 .NextLevel:    mov     eax,[Level]
                inc     eax                     ; Перейти к следующему уровню
                be      eax,MAX_LEVELS,.DemoEnd
                mov     [Level],eax
                jmp     .DemoLoop
 .DemoEnd:      pop     [GameMode]
                ret
endp
;==============================================================================

;=== DEMO THRU ALL LEVELS =====================================================
proc            DEMO_FROM_BEGIN
                xor     eax, eax
                mov     [Level],eax               ; Начать демонстрацию с начала
                ;;mov     esi, GameTitle
                ;;mov     edi, MAZE_SCREEN
                ;;call    SlideUp
                call    DEMO
                ret
endp
;==============================================================================

;=== PLAY LOOP ================================================================
proc            PlayLoop
                call    CalculateLevel          ; Подсчет алмазов и вычисление координат героя
;;;                call    MazeToMazeWork
                ;
                ; НАСТРОЙКА ЗАПИСИ / ВОСПРОИЗВЕДЕНИЯ
                ;
                be      [GameMode],MODE_DEMO,.L3
                call    RecorderInit
                jmp     .GameLoop
 .L3:           call    PlayerInit
                ;
                ; ИГРОВОЙ ЦИКЛ
                ;
 .GameLoop:     stdcall ProcessMessages, PM_EXIT_BY_TIMER, GAME_DELAY   ; Задержка игры, сканирование клавиатуры
                ;
                ; ПРОВЕРКА: СОБРАЛИ ВСЕ АЛМАЗЫ?
                ;
                bne     [AlmazesCount], 0, .readKey     ; Алмазов 0 ? Если НЕТ, продолжаем проверки
                be      [GameMode],MODE_DEMO,.LevelDone ; Демо - просто выходим
                call    RecorderStop                    ; Игра - остановить запись, выход
                jmp     .LevelDone
                ;
                ; ЧИТАЕМ НАЖАТУЮ КЛАВИШУ (ИЗ ДЕМО-ЗАПИСИ ИЛИ С КЛАВИАТУРЫ)
                ;
 .readKey:      bne     [GameMode],MODE_DEMO,.L1
                call    GrabKeyCode                     ; Проверяем, не нажали ли ESC (выход) ?
                be      eax, KBD_ESCAPE, .L2            ; Выход во время демо...
                call    PlayerGetKey                    ; Код клавиши извлекаем из ЗАПИСИ
                jmp     .L2
 .L1:           call    GrabKeyCode                     ; Читаем код нажатой клавиши
                call    RecorderPutKey                  ; Код клавиши ЗАПИСЫВАЕМ
 .L2:           mov     [KOD],eax
                be      eax, KBD_ESCAPE, .PlayBreak     ; Проверяем, не вышли ли мы из игрового цикла (клавиша ESC) ?
                ;
                ; ОБРАБОТКА ЛАБИРИНТА
                ;
                call    SKA1                            ; ДВИЖЕНИЕ!!!
                bne     [HeroDie],TRUE,.GameLoop        ; Если герой жив, продолжаем игровой цикл
                be      [KOD], KBD_DESTRUCT, .LevelBreak; Прерывание игры: смотрим, по какой причине и соответственно
                jmp     .HeroDie                        ; от этого зависит статус завершения игрового цикла
                ;
                ; ВЫХОД ИЗ ИГРОВОГО ЦИКЛА С УКАЗАНИЕМ ПРИЧИНЫ
                ;
 .LevelDone:    mov     eax,GAME_LVL_DONE               ; УРОВЕНЬ ПРОЙДЕН!!!
                ret
 .PlayBreak:    mov     eax,GAME_PLAY_END               ; ВЫХОД ИЗ ИГРЫ!!!
                ret
 .LevelBreak:   mov     eax,GAME_LVL_RESTART            ; ПЕРЕЗАПУСК УРОВНЯ!!!
                ret
 .HeroDie:      mov     eax,GAME_HERO_DIE               ; ЧЕЛОВЕЧКА ПРИБИЛО!!!
                ret                             
endp
;==============================================================================


                ; Ждем до тех пор, пока хоть что-то движется (кроме чудищ)
proc            WaitForSilent
 .Loop:         call    SKA1
                stdcall ProcessMessages, PM_EXIT_BY_TIMER, GAME_DELAY
                bne     [PSK], 0, .Loop
                ;
                call    BeepBolder
                stdcall DrawLevel, Maze
                call    BeepBolder
                ret
endp

                ; Писк после успешного прохождения уровня
proc            EndLevelSignal
                mov     edx,3
 .L1:           call    BeepBolder
                call    BeepBolder
                stdcall ProcessMessages, PM_EXIT_BY_TIMER, 5
                dec     edx
                jnz     .L1
                ret
endp

                ; Редактирование лабиринта
proc            EditLevel
                local   PrevUnder:BYTE
                mov     [GameMode],MODE_EDIT
                call    ExpandLevel
                stdcall DrawLevel, Maze
                mov     [PrevUnder],0
                xor     edx, edx                ; Координаты курсора (dh=y, dl=x)
                ; Цикл редактора
 .EditLoop:     movzx   esi, dh                 ; адрес в Maze = dh*16+dl; dh << 4 + dl
                imul    esi, MAZE_WIDTH
                movzx   edi, dl
                lea     esi, [esi+edi+Maze]
                ;
                mov     bl,[esi]                ; Мерцаем прямоугольником
                mov     byte [esi],42
                stdcall DrawLevel, Maze
                stdcall ProcessMessages, PM_EXIT_BY_KEY OR PM_EXIT_BY_TIMER, EDIT_CURSOR_DELAY
                mov     [esi], bl
                bb      eax, 255, .RSKL
                jmp     .L1
 .StoreNew:     mov     [esi], bl
 .L1:           stdcall DrawLevel, Maze
                stdcall ProcessMessages, PM_EXIT_BY_KEY OR PM_EXIT_BY_TIMER, EDIT_CURSOR_DELAY
                bb      eax, 255, .RSKL
                jmp     .EditLoop
                ;
 .RSKL:         br      eax, VK_0, VK_7, .StoreSprite
                switch  eax, VK_LEFT,    .L1L,        \
                             VK_RIGHT,   .L1R,        \
                             VK_UP,      .L1U,        \
                             VK_DOWN,    .L1D,        \
                             VK_DELETE,  .CLS,        \
                             VK_HOME,    .Home,       \
                             VK_END,     .End,        \
                             VK_RETURN,  .ENDSAVE,    \
                             VK_ESCAPE,  .ENDNOSAVE
                call    BeepBolder
                jmp     .EditLoop
                ;
 .StoreSprite:  mov     bl, al
                sub     bl, VK_0
                bne     bl, 5, .StoreNew
                ;
                mov     edi,Maze                ; Специальная обработка для человечка
                mov     ecx,16*12
                mov     al,5
                repne   scasb
                jne     .L2
                dec     edi
                mov     al,[PrevUnder]
                mov     [edi],al
 .L2:           mov     al,[esi]
                mov     [PrevUnder],al
                jmp     .StoreNew
                ;
 .Home:         mov     dl,0                    ; Перемещение курсора на первый столбец
                jmp     .EditLoop
 .End:          mov     dl,15                   ; Перемещение курсора на последний столбец
                jmp     .EditLoop
 .L1L:          be      dl,0,.EditLoop          ; Перемещение курсора ВЛЕВО (DL=DL-1)
                dec     dl
                jmp     .EditLoop
 .L1R:          be      dl,15,.EditLoop         ; Перемещение курсора ВПРАВО (DL=DL+1)
                inc     dl
                jmp     .EditLoop
 .L1U:          be      dh,0,.EditLoop          ; Перемещение курсора ВВЕРХ (DH=DH-1)
                dec     dh
                jmp     .EditLoop
 .L1D:          be      dh,11,.EditLoop         ; Перемещение курсора ВНИЗ (DH=DH+1)
                inc     dh
                jmp     .EditLoop
 .CLS:          mov     edi, Maze               ; Очистка лабиринта
                mov     ecx, 16*12/4
                xor     eax, eax
                rep     stosd
                jmp     .EditLoop
 .ENDSAVE:      call    CompressLevel
 .ENDNOSAVE:    ret
endp

proc            SelectLevelForEditing
                mov     [Level],0
                mov     esi,GameTitle
                mov     edi,MAZE_SCREEN
                call    SlideDown
                ;
NewLoop:        call    ExpandLevel
                ;
                GET_DEMO_PTR                            ; Проверить, есть ли демо ?
                or      eax, eax
                mov     eax, MODE_VIEW
                jz      .L1
                mov     eax,MODE_VIDA
 .L1:           mov     [GameMode],eax
                ;
                stdcall DrawLevel, Maze
SelectLoop:     stdcall ProcessMessages, PM_EXIT_BY_KEY, 0
                switch  eax, VK_ESCAPE, .Done, \
                             VK_RETURN, .Edit, \
                             VK_HOME,   .Home, \
                             VK_END,    .End,  \
                             VK_RIGHT,  .Next, \
                             VK_PGDN,   .Next, \
                             VK_LEFT,   .Prev, \
                             VK_PGUP,   .Prev
                ;be      eax,VK_R,VIEW_TEST
                ;be      eax,VK_D,VIEW_DEMO
                jmp     SelectLoop
                ;
 .Store:        mov     [Level],eax
                jmp     NewLoop
                ;
 .Edit:         call    EditLevel
                jmp     NewLoop
                ;
 .Next:         mov     eax, [Level]
                be      eax, MAX_LEVELS-1, .Home
                inc     eax
                jmp     .Store
                ;
 .Home:         mov     eax, 0
                jmp     .Store
                ;
 .Prev:         mov     eax, [Level]
                be      eax, 0, .End
                dec     eax
                jmp     .Store
                ;
 .End:          mov     eax, MAX_LEVELS-1
                jmp     .Store
                ;

;;VIEW_TEST:      call    TEST1
;;                mov     si,BLACK_SCREEN
;;                mov     di,MAZE_SCREEN
;;                call    SlideUp
;;                jmp     ViewNewLoop

;;VIEW_DEMO:      call    DEMO1
;;                mov     si,BLACK_SCREEN
;;                mov     di,MAZE_SCREEN
;;                call    SlideUp
;;                jmp     ViewNewLoop
  .Done:        ret
endp

                ; Произвести короткий звучек!!!
proc            SOO
                push    ecx
                mov     ecx,5
 .L1:           call    BeepBolder
                loop    .L1
                pop     ecx
                ret
endp

;=== Общие макросы для ЗАПИСИ / ВОСПРОИЗВЕДЕНИЯ ===============================
END_RLE_KEY     =       (1 SHL 8) OR KBD_DESTRUCT     ; Код самоуничтожения

;=== ЗАПИСЬ игры ==============================================================
                ; Инициализация записывателя
proc            RecorderInit
                mov     eax,RecArray
                mov     [RecPtr],eax
                mov     [RecSize], 0
                mov     [RecCode], -1
                ret
endp

                ; Процедура записывает количество и код нажатых клавиш
                ; IN    bh = counter (5 bit)
                ;       bl = keycode (3 bit)
                ; OUT   -
proc            Recorder_Helper_Write uses edi ebx
                mov     edi, [RecPtr]
                shl     bh, 3
                or      bl, bh
                mov     [edi], bl
                inc     edi
                mov     [RecPtr], edi
                inc     [RecSize]
                ret
endp

                ; Записать код нажатой клавиши (код в AH)
                ; IN    eax = код клавиши (0..7)
                ; OUT   -
proc            RecorderPutKey uses ebx
                mov     ebx, [RecCode]                  ; BH = count, BL = keycode (default, BH=-1, BL=-1)
                cmp     ebx, -1
                je      .newcode
                cmp     bh, 11111b                      ; Счётчик уже на последнем значении?
                je      .counteroverflow
                cmp     al, bl
                jne     .counteroverflow
                inc     bh
                jmp     .L1
 .counteroverflow:
                call    Recorder_Helper_Write
 .newcode:      mov     bh, 1
                mov     bl, al
 .L1:           mov     [RecCode], ebx
                ret
endp

proc            RecorderStop
                pushad
                mov     ebx, [RecCode]
                be      ebx, -1, .L1                    ; Переход, если ничего не было записано
                call    Recorder_Helper_Write
 .L1:           mov     esi, RecArray
                mov     ecx, [RecSize]
                GET_DEMO_INDEX
                call    ReplaceResource
                call    SaveMainFiles
                popad
                ret
endp

;=== ВОСПРОИЗВЕДЕНИЕ записанной игры ==========================================
proc            Player_Helper_Read uses esi
                mov     esi, [RecSize]
                be      esi, 0, .nodata
                dec     esi
                mov     [RecSize], esi
                ;
                mov     esi, [RecPtr]
                movzx   eax, byte [esi]
                inc     esi
                mov     [RecPtr], esi
                ;
                mov     ah, al
                shr     ah, 3
                and     al, 0111b
                ret
 .nodata:       mov     eax, END_RLE_KEY
                ret
endp

                ; Инициализация плейера для воспроизведения...
proc            PlayerInit
                GET_DEMO_PTR
                mov     [RecSize], eax
                mov     [RecPtr], esi
                call    Player_Helper_Read
                mov     [RecCode], eax
                ret
endp

                ; Вернуть записанную клавишу
proc            PlayerGetKey
                mov     eax, [RecCode]                  ; AH = счётчик, AL = код события
 .L1:           dec     ah
                jns     .L2
                call    Player_Helper_Read
                jmp     .L1
 .L2:           mov     [RecCode], eax
                movzx   eax, al                         ; Оставляем только код события
                ret
endp

;==============================================================================
                ; 
                ; Копировать лабиринт
                ;
                ; IN    esi - код лабиринта (BLACK_SCREEN - чёрный экран, 
                ;                            MAZE_SCREEN - лабиринт по номеру [Level],
                ;                            иначе адрес распакованного лабиринта)
                ;       edi - куда копировать лабиринт
                ;
                ; OUT   edi - адрес, указывающий на следующую область после лабиринта (IN:edi + размер лабиринта)
                ;
proc            MoveOrFill uses ecx esi eax
                mov     ecx,16*12
                be      esi,BLACK_SCREEN,.L1
                bne     esi,MAZE_SCREEN,.L0
                call    ExpandLevel
                mov     esi,Maze
 .L0:           rep     movsb
                ret
                ;
 .L1:           mov     al,0
                rep     stosb
                ret
endp

proc            SlideUpAndBeep
                call    SlideUp
                call    BeepBolder
                ret
endp

                ;
                ; Прокрутка экрана (начальный экран -> конечный экран)
                ;
                ; IN    esi = адрес начального экрана (0 для черного экрана)
                ;       edi = адрес конечного экрана (0 для черного экрана)
                ;
proc            SlideUp
                pushad
                mov     ebx,edi
                mov     edi,ScrollArea
                call    MoveOrFill
                mov     esi,ebx
                call    MoveOrFill
                mov     esi,ScrollArea
                mov     ecx,13
 .L5:           stdcall DrawLevel, esi
                add     esi,16
                stdcall ProcessMessages, PM_EXIT_BY_TIMER, SLIDE_DELAY
                loop    .L5
                popad
                ret
endp

proc            SlideDownAndBeep
                call    SlideDown
                call    BeepBolder
                ret
endp

                ;
                ; Прокрутка экрана (конечный экран -> начальный экран)
                ;
                ; IN    esi = адрес начального экрана (0 для черного экрана)
                ;       edi = адрес конечного экрана (0 для черного экрана)
                ;
proc            SlideDown
                pushad
                mov     ebx,esi
                mov     esi,edi
                mov     edi,ScrollArea
                call    MoveOrFill
                mov     esi,ebx
                call    MoveOrFill
                mov     esi,ScrollArea+16*12
                mov     ecx,13
 .L1:           stdcall DrawLevel, esi
                sub     esi,16
                stdcall ProcessMessages, PM_EXIT_BY_TIMER, SLIDE_DELAY
                loop    .L1
                popad
                ret
endp

                END
