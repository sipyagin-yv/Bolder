                format  PE CONSOLE
                include "win32wx.inc"

MODEL_BITS      =       13
MODEL_COUNT     =       (1 SHL MODEL_BITS)
MODEL_MASK      =       MODEL_COUNT-1

                .data
struct          model_freq_item
bit0            rd      1
bit1            rd      1
ends

compressedData  file    "levels.ac"

fn_levels       du      'levels.bin', 0
fn_freq         du      'levels.freq', 0

                align   16
levels          rb      192*200
model_freq      rb      sizeof.model_freq_item * MODEL_COUNT
model_mid       rd      1
counter         rd      1
source_ptr      rd      1
dest_ptr        rd      1

                .code
                include "fileio.inc"

start:          mov     esi, compressedData
                mov     edi, levels
                mov     ecx, 38400
                call    DecodeAC

                stdcall SaveFile, fn_levels, levels, 38400
                stdcall SaveFile, fn_freq, model_freq, sizeof.model_freq_item * MODEL_COUNT
                ret

proc            DecodeAC
                pushad
                mov     [counter], ecx          ; Размер для распаковки
                mov     [dest_ptr], edi
                ; Инициализируем таблицу частот
                mov     edi, model_freq
                mov     ecx, MODEL_COUNT * 2
                mov     eax, 1                  ; Начальное значение freq
                rep     stosd
                ; Начало распаковки
                lodsd                           ; загружаем три байта из сжатых данных:
                bswap   eax                     ; eax = 00 | [esi+0] | [esi+1] | [esi+2]
                shr     eax, 8
                dec     esi
                mov     [source_ptr], esi
                mov     ecx, eax                ; model_val
                mov     esi, 000000h            ; model_min
                mov     edi, 1000000h           ; model_max
                xor     ebp, ebp                ; model_bits
 .LoopByte:     mov     edx, 3                  ; dl = количество записываемых бит в байт; dh = формируемый выходной байт
                ; Вычисляем очередной бит
                ; Model_Predict( range )
                ; {
                ;   v0 = model_freq[bits].stat[0]
                ;   v1 = model_freq[bits].stat[1]
                ;   return = range * v0 / (v0 + v1)
                ; }
                ; Mid := Min + Model_Predict( Max-Min-1 );
 .LoopBits:     mov     eax, edi
                sub     eax, esi
                dec     eax

                push    edx
                mov     ebx, dword [model_freq + ebp*8 + 0]           ; model_freq[bits].stat[0]
                mul     ebx
                add     ebx, dword [model_freq + ebp*8 + 4]           ; model_freq[bits].stat[1]
                div     ebx
                pop     edx
                add     eax, esi

                ; eax = model_mid
                ; ebx = <free>
                ; ecx = model_val
                ; edx = conter and byte
                ; ebp = bits
                ; esi = model_min
                ; edi = model_max

                ; if Mid=Min then Inc(Mid)              ; if( eax == esi ) eax++;
                cmp     eax, esi
                jne     .L2
                inc     eax
                ; if (Mid=(Max-1)) then Dec(Mid);
 .L2:           lea     ebx, [edi-1]
                cmp     eax, ebx
                jne     .L3
                dec     eax
                ; if (Val>=Mid) then
                ; begin
                ;   Bit:=1;
                ;   Min:=Mid;
                ; end else
                ; begin
                ;   Bit:=0;
                ;   Max:=Mid;
                ; end;
 .L3:           cmp     ecx, eax
                jb      .bit0
                mov     ebx, 1
                mov     esi, eax
                jmp     .L4
 .bit0:         mov     ebx, 0
                mov     edi, eax
                ; Model_Update(Bit)
                ; {
                ;    model_freq[bits].stat[bit]++;
                ;    bits = ((bits << 1) | Bit) & model_mask
                ; }
 .L4:           lea     eax, [ebx*4]
                inc     dword [model_freq + ebp*8 + eax]
                shl     ebp, 1
                or      ebp, ebx
                and     ebp, MODEL_MASK
                shl     dh, 1
                or      dh, bl
                ; while (Max-Min)<256 do
                ; {
 .LoopWhile:    mov     eax, edi
                sub     eax, esi
                cmp     eax, 256
                jae     .L5
                ;   // if Bit=1 then Dec(Max);
                ;   Dec(Max,Bit);
                or      ebx, ebx
                jz      .L6
                dec     edi
 .L6:           ;   Val:=((Val SHL 8) AND $FFFF00) OR GET_BYTE_FROM_SOURCE;
                shl     ecx, 8
                and     ecx, 0ffff00h
                mov     eax, [source_ptr]
                mov     cl, [eax]
                inc     eax
                mov     [source_ptr], eax
                ;   Min:=(Min SHL 8) AND $FFFF00;
                shl     esi, 8
                and     esi, 0ffff00h
                ;   Max:=(Max SHL 8) AND $FFFF00;
                shl     edi, 8
                and     edi, 0ffff00h
                ;   if (Min>=Max) then Max:=$1000000;
                cmp     esi, edi
                jb      .L7
                mov     edi, 1000000h
 .L7:           ; }
                jmp     .LoopWhile
 .L5:           dec     dl
                jnz     .LoopBits
                ; Сохранить байт в выходной поток
                mov     eax, [dest_ptr]
                mov     [eax], dh
                inc     eax
                mov     [dest_ptr],eax
                dec     [counter]
                jnz     .LoopByte
                popad
                ret
endp

                .end    start
